# SwiftIMAP Project Coding Standards

## Code Organization

- Protocol conformances for types should always be in a separate file named `Type+Protocol.swift`
- Group extensions next to their model definitions in the file structure
- Move files on the file system rather than generating them unnecessarily
- Maintain a clear directory structure:
  - `Sources/SwiftIMAP/` - Main module directory
  - `Sources/SwiftIMAP/Core/` - Core functionality
  - `Sources/SwiftIMAP/Extensions/` - Extensions
  - `Sources/SwiftIMAP/Models/` - Models
  - `Sources/SwiftIMAPCLI/` - CLI application
  - `Tests/SwiftIMAPTests/` - Test files
  - `Tests/SwiftIMAPTests/Resources/` - Test resources

## Iterating

- Always do `swift build` after making changes and fix errors and warnings
- By default, CLI applications run with minimal output (user-friendly mode)
- For debugging purposes, use one of the following options:
  - Set `ENABLE_DEBUG_OUTPUT=1` to enable detailed debug prints (e.g., `ENABLE_DEBUG_OUTPUT=1 swift run SwiftSMTPCLI`)
  - Set `OS_LOG_DISABLE=1` to view Swift Logger output for system-level logs
  - For maximum verbosity, use both: `OS_LOG_DISABLE=1 ENABLE_DEBUG_OUTPUT=1 swift run SwiftSMTPCLI`
- When inspecting code, Cursor should prioritize the debug output mode for better understanding of the application flow

## Swift Style Guidelines

- Prefer to formulate convenience methods as an extension on the Foundation base type
- Don't create functions consisting of a single line - replace with the single line directly
- Don't prefix type names with underscore - Swift has namespaces via modules
- For string conversion, prefer in this order:
  1. Custom initializers: `String(value)`
  2. Properties like `stringValue` or `description` only when a custom initializer isn't available
  3. `String(describing:)` as a last resort

## Access Control

- Ensure methods called from outside the module are marked as `public`
- Maintain a clear public interface for public types
- Methods or properties that should not be visible publicly should be `internal`, `private`, or `fileprivate`

## Imports

- Imports for a file should always be the absolute minimum required
- Don't import modules that aren't directly used in the file

## Package Structure

- Follow standard Swift Package Manager conventions for directory structure
- Avoid specifying explicit paths in Package.swift when using standard directory locations

## Error Handling

- Use meaningful error types and descriptive error messages
- Properly propagate errors up the call stack with appropriate context

## Asynchronous Code

- Use Swift's async/await pattern for asynchronous operations
- Ensure proper error handling in asynchronous contexts

## Logging

- CLI applications use a two-tier logging approach:
  - System logging: Swift Logger with OSLog integration for system-level events
  - Debug prints: User-friendly debug messages with the `debugPrint()` helper function
- Log levels follow this hierarchy:
  - `.critical`: For fatal application errors
  - `.error`: For errors that impact functionality but allow recovery
  - `.warning`: For potential issues that don't impact functionality
  - `.notice`: For important events in normal operation
  - `.info`: For general information about application flow
  - `.debug`: For detailed debugging information (normally suppressed)
  - `.trace`: For extremely detailed flow tracing (normally suppressed)
- Debug statements should be wrapped with the `debugPrint()` function, which conditionally prints when `ENABLE_DEBUG_OUTPUT=1` is set
- Production code should minimize direct `print()` calls in favor of the logging system
- Developers should run with `ENABLE_DEBUG_OUTPUT=1` when developing or debugging

## CLI Application Standards

- SwiftSMTPCLI and SwiftIMAPCLI should provide:
  - Clean, user-friendly output in normal operation
  - Detailed debug output when enabled with environment variables
  - Clear error messages that are helpful without being overly technical
- User-facing prints should be:
  - Concise and clear
  - Well-formatted with emoji or other visual cues where appropriate
  - Free of implementation details unless debug mode is enabled
- When implementing new CLI functionality:
  - Add appropriate debug prints wrapped in `debugPrint()`
  - Add user-facing prints for key progress indicators
  - Include error handling with user-friendly messages
- CLI applications should load configuration from environment variables or dotenv files
- Running CLIs for testing:
  - For user-friendly mode: `swift run SwiftSMTPCLI`
  - For developer mode: `ENABLE_DEBUG_OUTPUT=1 swift run SwiftSMTPCLI`

## Testing

- Use Swift Testing framework instead of XCTest for all unit tests
- Test files should be organized in the `Tests/SwiftIMAPTests/` directory
- Test resources should be placed in the `Tests/SwiftIMAPTests/Resources/` directory
- Test structs should be named with a suffix of `Tests` (e.g., `QuotedPrintableTests`)
- Use the `@Test` attribute to mark test methods
- Use the `#expect` macro for assertions instead of XCTest assertions
- Throw custom errors (e.g., `TestFailure`) instead of using `XCTFail`
- Test methods that access resources should be marked as `throws`
- Organize tests with clear MARK comments to separate different test categories
- Test files should follow the same naming convention as the files they test (e.g., `String+QuotedPrintable.swift` â†’ `QuotedPrintableTests.swift`) 