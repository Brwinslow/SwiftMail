# SwiftIMAP Project Coding Standards

## Code Organization

- Protocol conformances for types should always be in a separate file named `Type+Protocol.swift`
- Group extensions next to their model definitions in the file structure
- Move files on the file system rather than generating them unnecessarily
- Maintain a clear directory structure:
  - `Sources/SwiftIMAP/` - Main module directory
  - `Sources/SwiftIMAP/Core/` - Core functionality
  - `Sources/SwiftIMAP/Extensions/` - Extensions
  - `Sources/SwiftIMAP/Models/` - Models
  - `Sources/SwiftIMAPCLI/` - CLI application
  - `Tests/SwiftIMAPTests/` - Test files
  - `Tests/SwiftIMAPTests/Resources/` - Test resources

## Iterating

- Always do `swift build` after making changes and fix errors and warnings
- By default, CLI applications run with minimal output (user-friendly mode)
- For debugging purposes, use one of the following options:
  - **Recommended for development**: `ENABLE_DEBUG_OUTPUT=1 OS_ACTIVITY_DT_MODE=debug swift run SwiftIMAPCLI` or `ENABLE_DEBUG_OUTPUT=1 OS_ACTIVITY_DT_MODE=debug swift run SwiftSMTPCLI`
  - For basic debug output: `ENABLE_DEBUG_OUTPUT=1 swift run SwiftIMAPCLI` or `ENABLE_DEBUG_OUTPUT=1 swift run SwiftSMTPCLI`
  - For complete protocol communication: `ENABLE_DEBUG_OUTPUT=1 swift run SwiftIMAPCLI & log stream --predicate 'process == "SwiftIMAPCLI"' --debug`
- Note that SMTP and IMAP have different logging behaviors:
  - SMTP shows `[SMTPServer]` category logs for operations like connecting, sending emails, etc.
  - IMAP only shows `[Main]` category logs by default, with protocol details only visible via log stream
- When inspecting code, Cursor should prioritize the debug output mode for better understanding of the application flow
- For debugging specific issues:
  - Network connectivity problems: Use the log stream approach to see all protocol communication
  - Authentication issues: Check for redacted credentials in logs and verify environment variables
  - Performance issues: Run with time measurements (`time swift run SwiftIMAPCLI`)

## Swift Style Guidelines

- Prefer to formulate convenience methods as an extension on the Foundation base type
- Don't create functions consisting of a single line - replace with the single line directly
- Don't prefix type names with underscore - Swift has namespaces via modules
- For string conversion, prefer in this order:
  1. Custom initializers: `String(value)`
  2. Properties like `stringValue` or `description` only when a custom initializer isn't available
  3. `String(describing:)` as a last resort
- Use Swift's property wrappers and result builders where appropriate
- Prefer Swift's modern concurrency model (async/await) over completion handlers
- Use Swift's strong typing to your advantage - avoid stringly typed code

## Access Control

- Ensure methods called from outside the module are marked as `public`
- Maintain a clear public interface for public types
- Methods or properties that should not be visible publicly should be `internal`, `private`, or `fileprivate`
- Use `internal` as the default access level (implicit in Swift)
- Consider using `fileprivate` for types that should only be accessible within the same file

## Imports

- Imports for a file should always be the absolute minimum required
- Don't import modules that aren't directly used in the file
- Group imports logically: Swift standard library first, then Foundation/system frameworks, then third-party dependencies
- Use `@_exported import` sparingly and only when necessary for API design

## Package Structure

- Follow standard Swift Package Manager conventions for directory structure
- Avoid specifying explicit paths in Package.swift when using standard directory locations
- Organize targets logically:
  - Core functionality in base libraries
  - Protocol-specific code in dedicated modules
  - CLI applications in separate targets
  - Test targets matching their corresponding source targets

## Error Handling

- Use meaningful error types and descriptive error messages
- Properly propagate errors up the call stack with appropriate context
- Define custom error types using enums that conform to `Error`
- Include relevant context in error messages to aid debugging
- Use `do-catch` blocks to handle errors at appropriate levels
- Consider using `Result` type for functions that might fail but don't use `throws`

## Asynchronous Code

- Use Swift's async/await pattern for asynchronous operations
- Ensure proper error handling in asynchronous contexts
- Use structured concurrency with `Task` and task groups
- Be mindful of potential race conditions in concurrent code
- Use actors to protect mutable state in concurrent contexts
- Avoid mixing completion handler-based code with async/await when possible

## Logging

- CLI applications use a two-tier logging approach:
  - System logging: Swift Logger with OSLog integration for system-level events
  - Debug prints: User-friendly debug messages with the `debugPrint()` helper function
- Log levels follow this hierarchy:
  - `.critical`: For fatal application errors
  - `.error`: For errors that impact functionality but allow recovery
  - `.warning`: For potential issues that don't impact functionality
  - `.notice`: For important events in normal operation
  - `.info`: For general information about application flow
  - `.debug`: For detailed debugging information (normally suppressed)
  - `.trace`: For extremely detailed flow tracing (normally suppressed)
- Debug statements should be wrapped with the `debugPrint()` function, which conditionally prints when `ENABLE_DEBUG_OUTPUT=1` is set
- Production code should minimize direct `print()` calls in favor of the logging system
- Developers should run with `ENABLE_DEBUG_OUTPUT=1` when developing or debugging
- Protocol-specific logging:
  - IMAP: Use trace-level logging for protocol commands and responses
  - SMTP: Use trace-level logging for protocol commands and responses
  - Always redact sensitive information (passwords, authentication tokens) in logs
- Log messages should be:
  - Clear and concise
  - Grammatically correct
  - Free of unnecessary technical jargon
  - Helpful for debugging without requiring source code access

## CLI Application Standards

- SwiftSMTPCLI and SwiftIMAPCLI should provide:
  - Clean, user-friendly output in normal operation
  - Detailed debug output when enabled with environment variables
  - Clear error messages that are helpful without being overly technical
- User-facing prints should be:
  - Concise and clear
  - Well-formatted with emoji or other visual cues where appropriate
  - Free of implementation details unless debug mode is enabled
- When implementing new CLI functionality:
  - Add appropriate debug prints wrapped in `debugPrint()`
  - Add user-facing prints for key progress indicators
  - Include error handling with user-friendly messages
- CLI applications should load configuration from environment variables or dotenv files
- Running CLIs for testing:
  - For user-friendly mode: `swift run SwiftSMTPCLI`
  - For developer mode: `ENABLE_DEBUG_OUTPUT=1 OS_ACTIVITY_DT_MODE=debug swift run SwiftSMTPCLI`
- CLI output should follow a consistent format:
  - Use emoji prefixes for different types of output (üìß for emails, üìÅ for folders, etc.)
  - Use color when available (via ANSI escape codes) for highlighting important information
  - Provide clear progress indicators for long-running operations
  - Format tabular data in an aligned, readable manner

## Testing

- Use Swift Testing framework instead of XCTest for all unit tests
- Test files should be organized in the `Tests/SwiftIMAPTests/` directory
- Test resources should be placed in the `Tests/SwiftIMAPTests/Resources/` directory
- Test structs should be named with a suffix of `Tests` (e.g., `QuotedPrintableTests`)
- Use the `@Test` attribute to mark test methods
- Use the `#expect` macro for assertions instead of XCTest assertions
- Throw custom errors (e.g., `TestFailure`) instead of using `XCTFail`
- Test methods that access resources should be marked as `throws`
- Organize tests with clear MARK comments to separate different test categories
- Test files should follow the same naming convention as the files they test (e.g., `String+QuotedPrintable.swift` ‚Üí `QuotedPrintableTests.swift`)
- Running tests with debug output:
  - `ENABLE_DEBUG_OUTPUT=1 OS_ACTIVITY_DT_MODE=debug swift test`
  - `ENABLE_DEBUG_OUTPUT=1 OS_ACTIVITY_DT_MODE=debug swift test --filter "StringExtensionsTests"`
- Test coverage:
  - Aim for high test coverage of core functionality
  - Prioritize testing edge cases and error conditions
  - Use mocks for external dependencies (network, file system)
  - Include both unit tests and integration tests where appropriate 